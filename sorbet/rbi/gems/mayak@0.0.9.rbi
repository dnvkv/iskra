# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mayak` gem.
# Please instead update this file by running `bin/tapioca gem mayak`.

# source://mayak//lib/mayak/cache.rb#4
module Mayak; end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mayak//lib/mayak/cache.rb#5
module Mayak::Cache
  extend T::Generic

  interface!

  Key = type_member
  Value = type_member

  # @abstract
  #
  # source://mayak//lib/mayak/cache.rb#28
  sig { abstract.void }
  def clear; end

  # @abstract
  #
  # source://mayak//lib/mayak/cache.rb#32
  sig { abstract.params(key: Key).void }
  def delete(key); end

  # @abstract
  #
  # source://mayak//lib/mayak/cache.rb#24
  sig { abstract.params(key: Key, blk: T.proc.returns(Value)).returns(Value) }
  def fetch(key, &blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/cache.rb#16
  sig { abstract.params(key: Key).returns(T.nilable(Value)) }
  def read(key); end

  # @abstract
  #
  # source://mayak//lib/mayak/cache.rb#20
  sig { abstract.params(key: Key, value: Value).void }
  def write(key, value); end
end

# source://mayak//lib/mayak/caching/unbounded_cache.rb#5
module Mayak::Caching; end

# source://mayak//lib/mayak/caching/lru_cache.rb#6
class Mayak::Caching::LRUCache
  extend T::Generic
  include ::Mayak::Cache

  Key = type_member
  Value = type_member

  # source://mayak//lib/mayak/caching/lru_cache.rb#20
  sig { params(max_size: ::Integer).void }
  def initialize(max_size:); end

  # source://mayak//lib/mayak/caching/lru_cache.rb#53
  sig { override.void }
  def clear; end

  # source://mayak//lib/mayak/caching/lru_cache.rb#58
  sig { override.params(key: Key).void }
  def delete(key); end

  # source://mayak//lib/mayak/caching/lru_cache.rb#44
  sig { override.params(key: Key, blk: T.proc.returns(Value)).returns(Value) }
  def fetch(key, &blk); end

  # source://mayak//lib/mayak/caching/lru_cache.rb#17
  sig { returns(::Integer) }
  def max_size; end

  # source://mayak//lib/mayak/caching/lru_cache.rb#29
  sig { override.params(key: Key).returns(T.nilable(Value)) }
  def read(key); end

  # source://mayak//lib/mayak/caching/lru_cache.rb#34
  sig { override.params(key: Key, value: Value).void }
  def write(key, value); end

  private

  # source://mayak//lib/mayak/caching/lru_cache.rb#65
  sig { void }
  def evict!; end
end

# source://mayak//lib/mayak/caching/unbounded_cache.rb#6
class Mayak::Caching::UnboundedCache
  extend T::Generic
  include ::Mayak::Cache

  Key = type_member
  Value = type_member

  # source://mayak//lib/mayak/caching/unbounded_cache.rb#17
  sig { void }
  def initialize; end

  # source://mayak//lib/mayak/caching/unbounded_cache.rb#41
  sig { override.void }
  def clear; end

  # source://mayak//lib/mayak/caching/unbounded_cache.rb#46
  sig { override.params(key: Key).void }
  def delete(key); end

  # source://mayak//lib/mayak/caching/unbounded_cache.rb#32
  sig { override.params(key: Key, blk: T.proc.returns(Value)).returns(Value) }
  def fetch(key, &blk); end

  # source://mayak//lib/mayak/caching/unbounded_cache.rb#22
  sig { override.params(key: Key).returns(T.nilable(Value)) }
  def read(key); end

  # source://mayak//lib/mayak/caching/unbounded_cache.rb#27
  sig { override.params(key: Key, value: Value).void }
  def write(key, value); end
end

# source://mayak//lib/mayak/collections/priority_queue.rb#5
module Mayak::Collections; end

# source://mayak//lib/mayak/collections/priority_queue.rb#6
class Mayak::Collections::PriorityQueue
  extend T::Generic

  Element = type_member
  Priority = type_member

  # source://mayak//lib/mayak/collections/priority_queue.rb#17
  sig { params(compare: T.proc.params(arg0: Priority, arg2: Priority).returns(T::Boolean)).void }
  def initialize(&compare); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#54
  sig { void }
  def clear; end

  # source://mayak//lib/mayak/collections/priority_queue.rb#31
  sig { returns(T.nilable([Element, Priority])) }
  def dequeue; end

  # source://mayak//lib/mayak/collections/priority_queue.rb#65
  sig { returns(T::Boolean) }
  def empty?; end

  # source://mayak//lib/mayak/collections/priority_queue.rb#24
  sig { params(element: Element, priority: Priority).void }
  def enqueue(element, priority); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#49
  sig { returns(T.nilable([Element, Priority])) }
  def peak; end

  # source://mayak//lib/mayak/collections/priority_queue.rb#14
  sig { returns(::Integer) }
  def size; end

  # source://mayak//lib/mayak/collections/priority_queue.rb#60
  sig { returns(T::Array[[Element, Priority]]) }
  def to_a; end

  private

  # @raise [StandardError]
  #
  # source://mayak//lib/mayak/collections/priority_queue.rb#107
  sig { params(index1: ::Integer, index2: ::Integer).returns(T::Boolean) }
  def compare(index1, index2); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#130
  sig { params(index: ::Integer).returns(T::Boolean) }
  def has_left_child(index); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#120
  sig { params(index: ::Integer).returns(T::Boolean) }
  def has_parent(index); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#140
  sig { params(index: ::Integer).returns(T::Boolean) }
  def has_right_child(index); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#135
  sig { params(index: ::Integer).returns(::Integer) }
  def left_child_index(index); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#125
  sig { params(index: ::Integer).returns(::Integer) }
  def parent_index(index); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#145
  sig { params(index: ::Integer).returns(::Integer) }
  def right_child_index(index); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#150
  sig { params(index: ::Integer).returns(T::Boolean) }
  def root?(index); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#82
  sig { params(element_index: ::Integer).void }
  def sift_down(element_index); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#72
  sig { params(element_index: ::Integer).void }
  def sift_up(element_index); end

  # source://mayak//lib/mayak/collections/priority_queue.rb#102
  sig { params(index1: ::Integer, index2: ::Integer).void }
  def swap(index1, index2); end
end

# source://mayak//lib/mayak/collections/queue.rb#6
class Mayak::Collections::Queue
  extend T::Generic

  Value = type_member

  # source://mayak//lib/mayak/collections/queue.rb#28
  sig { params(initial: T::Array[Value]).void }
  def initialize(initial: T.unsafe(nil)); end

  # source://mayak//lib/mayak/collections/queue.rb#56
  sig { returns(T.nilable(Value)) }
  def dequeue; end

  # source://mayak//lib/mayak/collections/queue.rb#68
  sig { returns(T::Boolean) }
  def empty?; end

  # source://mayak//lib/mayak/collections/queue.rb#36
  sig { params(element: Value).void }
  def enqueue(element); end

  # source://mayak//lib/mayak/collections/queue.rb#49
  sig { returns(T.nilable(Value)) }
  def peak; end

  # source://mayak//lib/mayak/collections/queue.rb#25
  sig { returns(::Integer) }
  def size; end
end

# source://mayak//lib/mayak/collections/queue.rb#13
class Mayak::Collections::Queue::Node < ::T::Struct
  extend T::Generic

  Value = type_member

  const :value, Value
  prop :next, T.nilable(Mayak::Collections::Queue::Node[Value])

  class << self
    # source://sorbet-runtime/0.5.11349/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mayak//lib/mayak/function.rb#5
class Mayak::Function
  extend T::Generic

  Input = type_member
  Output = type_member

  # source://mayak//lib/mayak/function.rb#17
  sig { params(blk: T.proc.params(input: Input).returns(Output)).void }
  def initialize(&blk); end

  # @param another [Mayak::Function[T.type_parameter(:Input2), Input]]
  # @return [Mayak::Function[T.type_parameter(:Input2), Output]]
  #
  # source://sorbet-runtime/0.5.11349/lib/types/private/methods/_methods.rb#257
  def <<(*args, **_arg1, &blk); end

  # @param another [Mayak::Function[Output, T.type_parameter(:Output2)]]
  # @return [Mayak::Function[Input, T.type_parameter(:Output2)]]
  #
  # source://sorbet-runtime/0.5.11349/lib/types/private/methods/_methods.rb#257
  def >>(*args, **_arg1, &blk); end

  # source://mayak//lib/mayak/function.rb#31
  sig do
    type_parameters(:Output2)
      .params(
        another: Mayak::Function[Output, T.type_parameter(:Output2)]
      ).returns(Mayak::Function[Input, T.type_parameter(:Output2)])
  end
  def and_then(another); end

  # source://mayak//lib/mayak/function.rb#14
  sig { returns(T.proc.params(input: Input).returns(Output)) }
  def blk; end

  # source://mayak//lib/mayak/function.rb#22
  sig { params(input: Input).returns(Output) }
  def call(input); end

  # source://mayak//lib/mayak/function.rb#41
  sig do
    type_parameters(:Input2)
      .params(
        another: Mayak::Function[T.type_parameter(:Input2), Input]
      ).returns(Mayak::Function[T.type_parameter(:Input2), Output])
  end
  def compose(another); end
end

# source://mayak//lib/mayak/http/decoder.rb#5
module Mayak::Http; end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mayak//lib/mayak/http/client.rb#6
module Mayak::Http::Client
  interface!

  # @abstract
  #
  # source://mayak//lib/mayak/http/client.rb#13
  sig { abstract.params(request: ::Mayak::Http::Request).returns(Mayak::Monads::Try[::Mayak::Http::Response]) }
  def send_request(request); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mayak//lib/mayak/http/codec.rb#9
module Mayak::Http::Codec
  extend T::Generic
  include ::Mayak::Http::Encoder
  include ::Mayak::Http::Decoder

  interface!

  RequestEntity = type_member
  ResponseEntity = type_member
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mayak//lib/mayak/http/decoder.rb#6
module Mayak::Http::Decoder
  extend T::Generic

  interface!

  ResponseEntity = type_member

  # @abstract
  #
  # source://mayak//lib/mayak/http/decoder.rb#20
  sig { abstract.params(response: ::Mayak::Http::Response).returns(Mayak::Monads::Try[ResponseEntity]) }
  def decode(response); end
end

# source://mayak//lib/mayak/http/decoder.rb#23
class Mayak::Http::Decoder::IdentityDecoder
  extend T::Generic
  include ::Mayak::Http::Decoder

  ResponseEntity = type_member { { fixed: Mayak::Http::Response } }

  # source://mayak//lib/mayak/http/decoder.rb#37
  sig { override.params(response: ::Mayak::Http::Response).returns(Mayak::Monads::Try[ResponseEntity]) }
  def decode(response); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mayak//lib/mayak/http/encoder.rb#6
module Mayak::Http::Encoder
  extend T::Generic

  interface!

  RequestEntity = type_member

  # @abstract
  #
  # source://mayak//lib/mayak/http/encoder.rb#16
  sig { abstract.params(entity: RequestEntity).returns(::Mayak::Http::Request) }
  def encode(entity); end
end

# source://mayak//lib/mayak/http/encoder.rb#34
class Mayak::Http::Encoder::FromFunction
  extend T::Generic
  include ::Mayak::Http::Encoder

  RequestEntity = type_member

  # source://mayak//lib/mayak/http/encoder.rb#44
  sig { params(function: Mayak::Function[RequestEntity, ::Mayak::Http::Request]).void }
  def initialize(function); end

  # source://mayak//lib/mayak/http/encoder.rb#49
  sig { override.params(entity: RequestEntity).returns(::Mayak::Http::Request) }
  def encode(entity); end
end

# source://mayak//lib/mayak/http/encoder.rb#19
class Mayak::Http::Encoder::IdentityEncoder
  extend T::Generic
  include ::Mayak::Http::Encoder

  RequestEntity = type_member { { fixed: Mayak::Http::Request } }

  # source://mayak//lib/mayak/http/encoder.rb#29
  sig { override.params(entity: RequestEntity).returns(::Mayak::Http::Request) }
  def encode(entity); end
end

# source://mayak//lib/mayak/http/request.rb#9
class Mayak::Http::Request < ::T::Struct
  const :verb, ::Mayak::Http::Verb
  const :url, ::URI
  const :headers, T::Hash[::String, ::String], default: T.unsafe(nil)
  const :body, T.nilable(::String)

  # source://mayak//lib/mayak/http/request.rb#20
  sig(:final) { params(other: ::Mayak::Http::Request).returns(T::Boolean) }
  def ==(other); end

  # source://mayak//lib/mayak/http/request.rb#35
  sig { returns(T.nilable(::String)) }
  def content_type; end

  # source://mayak//lib/mayak/http/request.rb#25
  sig(:final) { params(other: ::Mayak::Http::Request).returns(T::Boolean) }
  def eql?(other); end

  # source://mayak//lib/mayak/http/request.rb#30
  sig { returns(::Integer) }
  def hash; end

  # source://mayak//lib/mayak/http/request.rb#40
  sig { params(type: ::String).returns(::Mayak::Http::Request) }
  def with_content_type(type); end

  class << self
    # source://mayak//lib/mayak/http/request.rb#100
    sig do
      params(
        url: ::URI,
        headers: T::Hash[::String, ::String],
        body: T.nilable(::String)
      ).returns(::Mayak::Http::Request)
    end
    def delete(url:, headers: T.unsafe(nil), body: T.unsafe(nil)); end

    # source://mayak//lib/mayak/http/request.rb#50
    sig do
      params(
        url: ::URI,
        headers: T::Hash[::String, ::String],
        body: T.nilable(::String)
      ).returns(::Mayak::Http::Request)
    end
    def get(url:, headers: T.unsafe(nil), body: T.unsafe(nil)); end

    # source://mayak//lib/mayak/http/request.rb#60
    sig do
      params(
        url: ::URI,
        headers: T::Hash[::String, ::String],
        body: T.nilable(::String)
      ).returns(::Mayak::Http::Request)
    end
    def head(url:, headers: T.unsafe(nil), body: T.unsafe(nil)); end

    # source://sorbet-runtime/0.5.11349/lib/types/struct.rb#13
    def inherited(s); end

    # source://mayak//lib/mayak/http/request.rb#90
    sig do
      params(
        url: ::URI,
        headers: T::Hash[::String, ::String],
        body: T.nilable(::String)
      ).returns(::Mayak::Http::Request)
    end
    def patch(url:, headers: T.unsafe(nil), body: T.unsafe(nil)); end

    # source://mayak//lib/mayak/http/request.rb#70
    sig do
      params(
        url: ::URI,
        headers: T::Hash[::String, ::String],
        body: T.nilable(::String)
      ).returns(::Mayak::Http::Request)
    end
    def post(url:, headers: T.unsafe(nil), body: T.unsafe(nil)); end

    # source://mayak//lib/mayak/http/request.rb#80
    sig do
      params(
        url: ::URI,
        headers: T::Hash[::String, ::String],
        body: T.nilable(::String)
      ).returns(::Mayak::Http::Request)
    end
    def put(url:, headers: T.unsafe(nil), body: T.unsafe(nil)); end
  end
end

# source://mayak//lib/mayak/http/request.rb#17
Mayak::Http::Request::CONTENT_TYPE_HEADER = T.let(T.unsafe(nil), String)

# source://mayak//lib/mayak/http/response.rb#8
class Mayak::Http::Response < ::T::Struct
  const :status, ::Integer
  const :headers, T::Hash[::String, ::String], default: T.unsafe(nil)
  const :body, ::String, default: T.unsafe(nil)

  # source://mayak//lib/mayak/http/response.rb#24
  sig { returns(T::Boolean) }
  def failure?; end

  # source://mayak//lib/mayak/http/response.rb#19
  sig { returns(T::Boolean) }
  def success?; end

  class << self
    # source://sorbet-runtime/0.5.11349/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mayak//lib/mayak/http/response.rb#12
Mayak::Http::Response::StatusesWithoutBody = T.let(T.unsafe(nil), Set)

# source://mayak//lib/mayak/http/response.rb#11
Mayak::Http::Response::SuccessfulStatuses = T.let(T.unsafe(nil), Set)

# source://mayak//lib/mayak/http/verb.rb#6
class Mayak::Http::Verb < ::T::Enum
  enums do
    Get = new
    Post = new
    Head = new
    Put = new
    Patch = new
    Delete = new
    Connect = new
    Options = new
    Trace = new
  end
end

# source://mayak//lib/mayak/json.rb#7
module Mayak::Json
  class << self
    # source://mayak//lib/mayak/json.rb#24
    sig do
      params(
        string: ::String
      ).returns(Mayak::Monads::Try[T.any(::Float, ::Integer, ::String, T::Array[T.untyped], T::Hash[T.untyped, T.untyped])])
    end
    def parse(string); end

    # source://mayak//lib/mayak/json.rb#31
    sig do
      params(
        string: ::String
      ).returns(T.any(::Float, ::Integer, ::String, T::Array[T.untyped], T::Hash[T.untyped, T.untyped]))
    end
    def parse_unsafe!(string); end
  end
end

# source://mayak//lib/mayak/json.rb#10
Mayak::Json::JsonType = T.type_alias { T.any(::Float, ::Integer, ::String, T::Array[T.untyped], T::Hash[T.untyped, T.untyped]) }

# source://mayak//lib/mayak/json.rb#20
class Mayak::Json::ParsingError < ::StandardError; end

# source://mayak//lib/mayak/monads/maybe.rb#5
module Mayak::Monads; end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mayak//lib/mayak/monads/maybe.rb#6
module Mayak::Monads::Maybe
  extend T::Generic

  abstract!
  sealed!

  Value = type_member(:out)

  # source://mayak//lib/mayak/monads/maybe.rb#121
  sig(:final) { params(another: Mayak::Monads::Maybe[T.untyped]).returns(T::Boolean) }
  def ==(another); end

  # source://mayak//lib/mayak/monads/maybe.rb#98
  sig do
    type_parameters(:NewValue)
      .params(
        new_value: T.type_parameter(:NewValue)
      ).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
  end
  def as(new_value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#77
  sig do
    abstract
      .type_parameters(:NoneResult, :SomeResult)
      .params(
        none_branch: T.proc.returns(T.type_parameter(:NoneResult)),
        some_branch: T.proc.params(arg0: Value).returns(T.type_parameter(:SomeResult))
      ).returns(T.any(T.type_parameter(:NoneResult), T.type_parameter(:SomeResult)))
  end
  def either(none_branch, some_branch); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#41
  sig { abstract.params(blk: T.proc.params(arg0: Value).returns(T::Boolean)).returns(Mayak::Monads::Maybe[Value]) }
  def filter(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#33
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
  end
  def flat_map(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#22
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
  end
  def map(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#49
  sig { abstract.returns(T::Boolean) }
  def none?; end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#108
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        value: T.type_parameter(:NewValue)
      ).returns(Mayak::Monads::Maybe[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover(value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#117
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        maybe: Mayak::Monads::Maybe[T.type_parameter(:NewValue)]
      ).returns(Mayak::Monads::Maybe[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_with_maybe(maybe); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#45
  sig { abstract.returns(T::Boolean) }
  def some?; end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#66
  sig { abstract.params(blk: T.proc.params(arg0: Value).void).returns(Mayak::Monads::Maybe[Value]) }
  def tee(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#86
  sig do
    abstract
      .type_parameters(:Failure)
      .params(
        failure: T.type_parameter(:Failure)
      ).returns(Mayak::Monads::Result[T.type_parameter(:Failure), Value])
  end
  def to_result(failure); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#90
  sig { abstract.params(error: ::StandardError).returns(Mayak::Monads::Try[Value]) }
  def to_try(error); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/maybe.rb#58
  sig do
    abstract
      .type_parameters(:AnotherValue)
      .params(
        value: T.type_parameter(:AnotherValue)
      ).returns(T.any(T.type_parameter(:AnotherValue), Value))
  end
  def value_or(value); end

  class << self
    # source://mayak//lib/mayak/monads/maybe.rb#159
    sig do
      type_parameters(:Value)
        .params(
          value: T.type_parameter(:Value),
          blk: T.proc.returns(T::Boolean)
        ).returns(Mayak::Monads::Maybe[T.type_parameter(:Value)])
    end
    def check(value, &blk); end

    # source://mayak//lib/mayak/monads/maybe.rb#168
    sig { params(blk: T.proc.returns(T::Boolean)).returns(Mayak::Monads::Maybe[::NilClass]) }
    def guard(&blk); end

    # source://mayak//lib/mayak/monads/maybe.rb#145
    sig do
      type_parameters(:Value)
        .params(
          results: T::Array[Mayak::Monads::Maybe[T.type_parameter(:Value)]]
        ).returns(Mayak::Monads::Maybe[T::Array[T.type_parameter(:Value)]])
    end
    def sequence(results); end
  end
end

# source://mayak//lib/mayak/monads/maybe.rb#423
module Mayak::Monads::Maybe::Mixin
  include ::Kernel

  # source://mayak//lib/mayak/monads/maybe.rb#433
  sig do
    type_parameters(:Value)
      .params(
        value: T.nilable(T.type_parameter(:Value))
      ).returns(Mayak::Monads::Maybe[T.type_parameter(:Value)])
  end
  def Maybe(value); end

  # source://mayak//lib/mayak/monads/maybe.rb#443
  sig { returns(Mayak::Monads::Maybe[T.untyped]) }
  def None; end

  # source://mayak//lib/mayak/monads/maybe.rb#480
  sig do
    type_parameters(:Value)
      .params(
        value: T.type_parameter(:Value),
        blk: T.proc.returns(T::Boolean)
      ).returns(T.type_parameter(:Value))
  end
  def check_maybe!(value, &blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#464
  sig do
    type_parameters(:Value)
      .params(
        value: Mayak::Monads::Maybe[T.type_parameter(:Value)]
      ).returns(T.type_parameter(:Value))
  end
  def do_maybe!(value); end

  # source://mayak//lib/mayak/monads/maybe.rb#452
  sig do
    type_parameters(:Value)
      .params(
        blk: T.proc.returns(T.type_parameter(:Value))
      ).returns(Mayak::Monads::Maybe[T.type_parameter(:Value)])
  end
  def for_maybe(&blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#485
  sig { params(blk: T.proc.returns(T::Boolean)).void }
  def guard_maybe!(&blk); end
end

# source://mayak//lib/mayak/monads/maybe.rb#489
class Mayak::Monads::Maybe::Mixin::Halt < ::StandardError
  extend T::Generic

  SuccessType = type_member

  # source://mayak//lib/mayak/monads/maybe.rb#500
  sig { params(result: Mayak::Monads::Maybe[SuccessType]).void }
  def initialize(result); end

  # source://mayak//lib/mayak/monads/maybe.rb#497
  sig { returns(Mayak::Monads::Maybe[SuccessType]) }
  def result; end
end

# source://mayak//lib/mayak/monads/maybe.rb#302
class Mayak::Monads::Maybe::None
  extend T::Generic
  include ::Mayak::Monads::Maybe

  Value = type_member

  # source://mayak//lib/mayak/monads/maybe.rb#383
  sig do
    override
      .type_parameters(:NoneResult, :SomeResult)
      .params(
        none_branch: T.proc.returns(T.type_parameter(:NoneResult)),
        some_branch: T.proc.params(arg0: Value).returns(T.type_parameter(:SomeResult))
      ).returns(T.any(T.type_parameter(:NoneResult), T.type_parameter(:SomeResult)))
  end
  def either(none_branch, some_branch); end

  # source://mayak//lib/mayak/monads/maybe.rb#342
  sig do
    override
      .params(
        blk: T.proc.params(arg0: Value).returns(T::Boolean)
      ).returns(Mayak::Monads::Maybe[Value])
  end
  def filter(&blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#330
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
  end
  def flat_map(&blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#317
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
  end
  def map(&blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#352
  sig(:final) { override.returns(T::Boolean) }
  def none?; end

  # source://mayak//lib/mayak/monads/maybe.rb#408
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        value: T.type_parameter(:NewValue)
      ).returns(Mayak::Monads::Maybe[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover(value); end

  # source://mayak//lib/mayak/monads/maybe.rb#418
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        maybe: Mayak::Monads::Maybe[T.type_parameter(:NewValue)]
      ).returns(Mayak::Monads::Maybe[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_with_maybe(maybe); end

  # source://mayak//lib/mayak/monads/maybe.rb#347
  sig(:final) { override.returns(T::Boolean) }
  def some?; end

  # source://mayak//lib/mayak/monads/maybe.rb#371
  sig(:final) { override.params(blk: T.proc.params(arg0: Value).void).returns(Mayak::Monads::Maybe[Value]) }
  def tee(&blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#393
  sig do
    override
      .type_parameters(:Failure)
      .params(
        failure: T.type_parameter(:Failure)
      ).returns(Mayak::Monads::Result[T.type_parameter(:Failure), Value])
  end
  def to_result(failure); end

  # source://mayak//lib/mayak/monads/maybe.rb#398
  sig(:final) { override.params(error: ::StandardError).returns(Mayak::Monads::Try[Value]) }
  def to_try(error); end

  # source://mayak//lib/mayak/monads/maybe.rb#362
  sig do
    override
      .type_parameters(:AnotherValue)
      .params(
        value: T.any(T.type_parameter(:AnotherValue), Value)
      ).returns(T.any(T.type_parameter(:AnotherValue), Value))
  end
  def value_or(value); end
end

# source://mayak//lib/mayak/monads/maybe.rb#172
class Mayak::Monads::Maybe::Some
  extend T::Generic
  include ::Mayak::Monads::Maybe

  Value = type_member

  # source://mayak//lib/mayak/monads/maybe.rb#182
  sig(:final) { params(value: Value).void }
  def initialize(value); end

  # source://mayak//lib/mayak/monads/maybe.rb#262
  sig do
    override
      .type_parameters(:NoneResult, :SomeResult)
      .params(
        none_branch: T.proc.returns(T.type_parameter(:NoneResult)),
        some_branch: T.proc.params(arg0: Value).returns(T.type_parameter(:SomeResult))
      ).returns(T.any(T.type_parameter(:NoneResult), T.type_parameter(:SomeResult)))
  end
  def either(none_branch, some_branch); end

  # source://mayak//lib/mayak/monads/maybe.rb#211
  sig do
    override
      .params(
        blk: T.proc.params(arg0: Value).returns(T::Boolean)
      ).returns(Mayak::Monads::Maybe[Value])
  end
  def filter(&blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#202
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
  end
  def flat_map(&blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#192
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Maybe[T.type_parameter(:NewValue)])
  end
  def map(&blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#230
  sig(:final) { override.returns(T::Boolean) }
  def none?; end

  # source://mayak//lib/mayak/monads/maybe.rb#287
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        value: T.type_parameter(:NewValue)
      ).returns(Mayak::Monads::Maybe[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover(value); end

  # source://mayak//lib/mayak/monads/maybe.rb#297
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        maybe: Mayak::Monads::Maybe[T.type_parameter(:NewValue)]
      ).returns(Mayak::Monads::Maybe[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_with_maybe(maybe); end

  # source://mayak//lib/mayak/monads/maybe.rb#225
  sig(:final) { override.returns(T::Boolean) }
  def some?; end

  # source://mayak//lib/mayak/monads/maybe.rb#249
  sig(:final) { override.params(blk: T.proc.params(arg0: Value).void).returns(Mayak::Monads::Maybe[Value]) }
  def tee(&blk); end

  # source://mayak//lib/mayak/monads/maybe.rb#272
  sig do
    override
      .type_parameters(:Failure)
      .params(
        failure: T.type_parameter(:Failure)
      ).returns(Mayak::Monads::Result[T.type_parameter(:Failure), Value])
  end
  def to_result(failure); end

  # source://mayak//lib/mayak/monads/maybe.rb#277
  sig(:final) { override.params(error: ::StandardError).returns(Mayak::Monads::Try[Value]) }
  def to_try(error); end

  # source://mayak//lib/mayak/monads/maybe.rb#220
  sig(:final) { returns(Value) }
  def value; end

  # source://mayak//lib/mayak/monads/maybe.rb#240
  sig do
    override
      .type_parameters(:AnotherValue)
      .params(
        value: T.any(T.type_parameter(:AnotherValue), Value)
      ).returns(T.any(T.type_parameter(:AnotherValue), Value))
  end
  def value_or(value); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mayak//lib/mayak/monads/result.rb#6
module Mayak::Monads::Result
  extend T::Generic

  abstract!
  sealed!

  FailureType = type_member(:out)
  SuccessType = type_member(:out)

  # source://mayak//lib/mayak/monads/result.rb#143
  sig(:final) { params(another: Mayak::Monads::Result[T.untyped, T.untyped]).returns(T::Boolean) }
  def ==(another); end

  # source://mayak//lib/mayak/monads/result.rb#167
  sig do
    type_parameters(:NewValue)
      .params(
        new_value: T.type_parameter(:NewValue)
      ).returns(Mayak::Monads::Result[FailureType, T.type_parameter(:NewValue)])
  end
  def as(new_value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#98
  sig do
    abstract
      .type_parameters(:Result)
      .params(
        failure_branch: T.proc.params(arg0: FailureType).returns(T.type_parameter(:Result)),
        success_branch: T.proc.params(arg0: SuccessType).returns(T.type_parameter(:Result))
      ).returns(T.type_parameter(:Result))
  end
  def either(failure_branch, success_branch); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#51
  sig { abstract.returns(T::Boolean) }
  def failure?; end

  # source://mayak//lib/mayak/monads/result.rb#106
  sig do
    type_parameters(:NewFailure)
      .params(
        new_failure: T.type_parameter(:NewFailure)
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), SuccessType])
  end
  def failure_as(new_failure); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#69
  sig do
    abstract
      .type_parameters(:NewFailureType)
      .params(
        value: T.type_parameter(:NewFailureType)
      ).returns(T.any(FailureType, T.type_parameter(:NewFailureType)))
  end
  def failure_or(value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#43
  sig do
    abstract
      .type_parameters(:NewFailure)
      .params(
        error: T.type_parameter(:NewFailure),
        blk: T.proc.params(arg0: SuccessType).returns(T::Boolean)
      ).returns(Mayak::Monads::Result[T.any(FailureType, T.type_parameter(:NewFailure)), SuccessType])
  end
  def filter_or(error, &blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#34
  sig do
    abstract
      .type_parameters(:NewFailure, :NewSuccess)
      .params(
        blk: T.proc.params(arg0: SuccessType).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.type_parameter(:NewSuccess)])
      ).returns(Mayak::Monads::Result[T.any(FailureType, T.type_parameter(:NewFailure)), T.type_parameter(:NewSuccess)])
  end
  def flat_map(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#139
  sig do
    abstract
      .type_parameters(:NewFailure, :NewSuccess)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.type_parameter(:NewSuccess)])
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.any(SuccessType, T.type_parameter(:NewSuccess))])
  end
  def flat_map_failure(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#73
  sig { abstract.returns(Mayak::Monads::Result[SuccessType, FailureType]) }
  def flip; end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#23
  sig do
    abstract
      .type_parameters(:NewSuccess)
      .params(
        blk: T.proc.params(arg0: SuccessType).returns(T.type_parameter(:NewSuccess))
      ).returns(Mayak::Monads::Result[FailureType, T.type_parameter(:NewSuccess)])
  end
  def map(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#127
  sig do
    abstract
      .type_parameters(:NewFailure)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(T.type_parameter(:NewFailure))
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), SuccessType])
  end
  def map_failure(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#177
  sig do
    abstract
      .type_parameters(:NewSuccess)
      .params(
        value: T.type_parameter(:NewSuccess)
      ).returns(Mayak::Monads::Result[FailureType, T.any(SuccessType, T.type_parameter(:NewSuccess))])
  end
  def recover(value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#186
  sig do
    abstract
      .type_parameters(:NewSuccessType)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(T.type_parameter(:NewSuccessType))
      ).returns(Mayak::Monads::Result[FailureType, T.any(SuccessType, T.type_parameter(:NewSuccessType))])
  end
  def recover_with(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#198
  sig do
    abstract
      .type_parameters(:NewFailure, :NewSuccess)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.type_parameter(:NewSuccess)])
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.any(SuccessType, T.type_parameter(:NewSuccess))])
  end
  def recover_with_result(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#47
  sig { abstract.returns(T::Boolean) }
  def success?; end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#60
  sig do
    abstract
      .type_parameters(:NewSuccessType)
      .params(
        value: T.type_parameter(:NewSuccessType)
      ).returns(T.any(SuccessType, T.type_parameter(:NewSuccessType)))
  end
  def success_or(value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#115
  sig do
    abstract
      .params(
        blk: T.proc.params(arg0: SuccessType).void
      ).returns(Mayak::Monads::Result[FailureType, SuccessType])
  end
  def tee(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#85
  sig { abstract.returns(Mayak::Monads::Maybe[SuccessType]) }
  def to_maybe; end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/result.rb#81
  sig do
    abstract
      .params(
        blk: T.proc.params(arg0: FailureType).returns(::StandardError)
      ).returns(Mayak::Monads::Try[SuccessType])
  end
  def to_try(&blk); end

  class << self
    # source://mayak//lib/mayak/monads/result.rb#217
    sig do
      type_parameters(:FailureType, :SuccessType)
        .params(
          results: T::Array[Mayak::Monads::Result[T.type_parameter(:FailureType), T.type_parameter(:SuccessType)]]
        ).returns(Mayak::Monads::Result[T.type_parameter(:FailureType), T::Array[T.type_parameter(:SuccessType)]])
    end
    def sequence(results); end
  end
end

# source://mayak//lib/mayak/monads/result.rb#425
class Mayak::Monads::Result::Failure
  extend T::Generic
  include ::Mayak::Monads::Result

  FailureType = type_member
  SuccessType = type_member

  # source://mayak//lib/mayak/monads/result.rb#436
  sig(:final) { params(value: FailureType).void }
  def initialize(value); end

  # source://mayak//lib/mayak/monads/result.rb#542
  sig do
    override
      .type_parameters(:Result)
      .params(
        failure_branch: T.proc.params(arg0: FailureType).returns(T.type_parameter(:Result)),
        success_branch: T.proc.params(arg0: SuccessType).returns(T.type_parameter(:Result))
      ).returns(T.type_parameter(:Result))
  end
  def either(failure_branch, success_branch); end

  # source://mayak//lib/mayak/monads/result.rb#479
  sig(:final) { returns(FailureType) }
  def failure; end

  # source://mayak//lib/mayak/monads/result.rb#489
  sig(:final) { override.returns(T::Boolean) }
  def failure?; end

  # source://mayak//lib/mayak/monads/result.rb#509
  sig do
    override
      .type_parameters(:NewFailureType)
      .params(
        value: T.any(FailureType, T.type_parameter(:NewFailureType))
      ).returns(T.any(FailureType, T.type_parameter(:NewFailureType)))
  end
  def failure_or(value); end

  # source://mayak//lib/mayak/monads/result.rb#474
  sig do
    override
      .type_parameters(:NewFailure)
      .params(
        error: T.type_parameter(:NewFailure),
        blk: T.proc.params(arg0: SuccessType).returns(T::Boolean)
      ).returns(Mayak::Monads::Result[T.any(FailureType, T.type_parameter(:NewFailure)), SuccessType])
  end
  def filter_or(error, &blk); end

  # source://mayak//lib/mayak/monads/result.rb#461
  sig do
    override
      .type_parameters(:NewFailure, :NewSuccess)
      .params(
        blk: T.proc.params(arg0: SuccessType).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.type_parameter(:NewSuccess)])
      ).returns(Mayak::Monads::Result[T.any(FailureType, T.type_parameter(:NewFailure)), T.type_parameter(:NewSuccess)])
  end
  def flat_map(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#577
  sig do
    override
      .type_parameters(:NewFailure, :NewSuccess)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.type_parameter(:NewSuccess)])
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.any(SuccessType, T.type_parameter(:NewSuccess))])
  end
  def flat_map_failure(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#514
  sig(:final) { override.returns(Mayak::Monads::Result[SuccessType, FailureType]) }
  def flip; end

  # source://mayak//lib/mayak/monads/result.rb#446
  sig do
    override
      .type_parameters(:NewSuccess)
      .params(
        blk: T.proc.params(arg0: SuccessType).returns(T.type_parameter(:NewSuccess))
      ).returns(Mayak::Monads::Result[FailureType, T.type_parameter(:NewSuccess)])
  end
  def map(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#564
  sig do
    override
      .type_parameters(:NewFailure)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(T.type_parameter(:NewFailure))
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), SuccessType])
  end
  def map_failure(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#587
  sig do
    override
      .type_parameters(:NewSuccess)
      .params(
        value: T.type_parameter(:NewSuccess)
      ).returns(Mayak::Monads::Result[FailureType, T.any(SuccessType, T.type_parameter(:NewSuccess))])
  end
  def recover(value); end

  # source://mayak//lib/mayak/monads/result.rb#598
  sig do
    override
      .type_parameters(:NewSuccessType)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(T.type_parameter(:NewSuccessType))
      ).returns(Mayak::Monads::Result[FailureType, T.any(SuccessType, T.type_parameter(:NewSuccessType))])
  end
  def recover_with(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#613
  sig do
    override
      .type_parameters(:NewFailure, :NewSuccess)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.type_parameter(:NewSuccess)])
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.any(SuccessType, T.type_parameter(:NewSuccess))])
  end
  def recover_with_result(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#484
  sig(:final) { override.returns(T::Boolean) }
  def success?; end

  # source://mayak//lib/mayak/monads/result.rb#499
  sig do
    override
      .type_parameters(:NewSuccessType)
      .params(
        value: T.type_parameter(:NewSuccessType)
      ).returns(T.any(SuccessType, T.type_parameter(:NewSuccessType)))
  end
  def success_or(value); end

  # source://mayak//lib/mayak/monads/result.rb#551
  sig do
    override
      .params(
        blk: T.proc.params(arg0: SuccessType).void
      ).returns(Mayak::Monads::Result[FailureType, SuccessType])
  end
  def tee(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#528
  sig(:final) { override.returns(Mayak::Monads::Maybe[SuccessType]) }
  def to_maybe; end

  # source://mayak//lib/mayak/monads/result.rb#523
  sig do
    override
      .params(
        blk: T.proc.params(arg0: FailureType).returns(::StandardError)
      ).returns(Mayak::Monads::Try[SuccessType])
  end
  def to_try(&blk); end
end

# source://mayak//lib/mayak/monads/result.rb#226
class Mayak::Monads::Result::Success
  extend T::Generic
  include ::Mayak::Monads::Result

  FailureType = type_member
  SuccessType = type_member

  # source://mayak//lib/mayak/monads/result.rb#237
  sig(:final) { params(value: SuccessType).void }
  def initialize(value); end

  # source://mayak//lib/mayak/monads/result.rb#342
  sig do
    override
      .type_parameters(:Result)
      .params(
        failure_branch: T.proc.params(arg0: FailureType).returns(T.type_parameter(:Result)),
        success_branch: T.proc.params(arg0: SuccessType).returns(T.type_parameter(:Result))
      ).returns(T.type_parameter(:Result))
  end
  def either(failure_branch, success_branch); end

  # source://mayak//lib/mayak/monads/result.rb#289
  sig(:final) { override.returns(T::Boolean) }
  def failure?; end

  # source://mayak//lib/mayak/monads/result.rb#309
  sig do
    override
      .type_parameters(:NewFailureType)
      .params(
        value: T.any(FailureType, T.type_parameter(:NewFailureType))
      ).returns(T.any(FailureType, T.type_parameter(:NewFailureType)))
  end
  def failure_or(value); end

  # source://mayak//lib/mayak/monads/result.rb#270
  sig do
    override
      .type_parameters(:NewFailure)
      .params(
        error: T.type_parameter(:NewFailure),
        blk: T.proc.params(arg0: SuccessType).returns(T::Boolean)
      ).returns(Mayak::Monads::Result[T.any(FailureType, T.type_parameter(:NewFailure)), SuccessType])
  end
  def filter_or(error, &blk); end

  # source://mayak//lib/mayak/monads/result.rb#260
  sig do
    override
      .type_parameters(:NewFailure, :NewSuccess)
      .params(
        blk: T.proc.params(arg0: SuccessType).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.type_parameter(:NewSuccess)])
      ).returns(Mayak::Monads::Result[T.any(FailureType, T.type_parameter(:NewFailure)), T.type_parameter(:NewSuccess)])
  end
  def flat_map(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#381
  sig do
    override
      .type_parameters(:NewFailure, :NewSuccess)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.type_parameter(:NewSuccess)])
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.any(SuccessType, T.type_parameter(:NewSuccess))])
  end
  def flat_map_failure(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#314
  sig(:final) { override.returns(Mayak::Monads::Result[SuccessType, FailureType]) }
  def flip; end

  # source://mayak//lib/mayak/monads/result.rb#247
  sig do
    override
      .type_parameters(:NewSuccess)
      .params(
        blk: T.proc.params(arg0: SuccessType).returns(T.type_parameter(:NewSuccess))
      ).returns(Mayak::Monads::Result[FailureType, T.type_parameter(:NewSuccess)])
  end
  def map(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#365
  sig do
    override
      .type_parameters(:NewFailure)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(T.type_parameter(:NewFailure))
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), SuccessType])
  end
  def map_failure(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#394
  sig do
    override
      .type_parameters(:NewSuccess)
      .params(
        value: T.type_parameter(:NewSuccess)
      ).returns(Mayak::Monads::Result[FailureType, T.any(SuccessType, T.type_parameter(:NewSuccess))])
  end
  def recover(value); end

  # source://mayak//lib/mayak/monads/result.rb#404
  sig do
    override
      .type_parameters(:NewSuccessType)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(T.type_parameter(:NewSuccessType))
      ).returns(Mayak::Monads::Result[FailureType, T.any(SuccessType, T.type_parameter(:NewSuccessType))])
  end
  def recover_with(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#417
  sig do
    override
      .type_parameters(:NewFailure, :NewSuccess)
      .params(
        blk: T.proc.params(arg0: FailureType).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.type_parameter(:NewSuccess)])
      ).returns(Mayak::Monads::Result[T.type_parameter(:NewFailure), T.any(SuccessType, T.type_parameter(:NewSuccess))])
  end
  def recover_with_result(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#279
  sig(:final) { returns(SuccessType) }
  def success; end

  # source://mayak//lib/mayak/monads/result.rb#284
  sig(:final) { override.returns(T::Boolean) }
  def success?; end

  # source://mayak//lib/mayak/monads/result.rb#299
  sig do
    override
      .type_parameters(:NewSuccessType)
      .params(
        value: T.type_parameter(:NewSuccessType)
      ).returns(T.any(SuccessType, T.type_parameter(:NewSuccessType)))
  end
  def success_or(value); end

  # source://mayak//lib/mayak/monads/result.rb#351
  sig do
    override
      .params(
        blk: T.proc.params(arg0: SuccessType).void
      ).returns(Mayak::Monads::Result[FailureType, SuccessType])
  end
  def tee(&blk); end

  # source://mayak//lib/mayak/monads/result.rb#328
  sig(:final) { override.returns(Mayak::Monads::Maybe[SuccessType]) }
  def to_maybe; end

  # source://mayak//lib/mayak/monads/result.rb#323
  sig do
    override
      .params(
        blk: T.proc.params(arg0: FailureType).returns(::StandardError)
      ).returns(Mayak::Monads::Try[SuccessType])
  end
  def to_try(&blk); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mayak//lib/mayak/monads/try.rb#6
module Mayak::Monads::Try
  extend T::Generic

  abstract!
  sealed!

  Value = type_member(:out)

  # source://mayak//lib/mayak/monads/try.rb#116
  sig(:final) { params(other: Mayak::Monads::Try[T.untyped]).returns(T::Boolean) }
  def ==(other); end

  # source://mayak//lib/mayak/monads/try.rb#140
  sig do
    type_parameters(:NewValue)
      .params(
        new_value: T.type_parameter(:NewValue)
      ).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
  end
  def as(new_value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#74
  sig do
    abstract
      .type_parameters(:Result)
      .params(
        failure_branch: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:Result)),
        success_branch: T.proc.params(arg0: Value).returns(T.type_parameter(:Result))
      ).returns(T.type_parameter(:Result))
  end
  def either(failure_branch, success_branch); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#48
  sig { abstract.returns(T::Boolean) }
  def failure?; end

  # source://mayak//lib/mayak/monads/try.rb#145
  sig(:final) { params(new_failure: ::StandardError).returns(Mayak::Monads::Try[Value]) }
  def failure_as(new_failure); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#61
  sig { abstract.params(value: ::StandardError).returns(::StandardError) }
  def failure_or(value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#40
  sig do
    abstract
      .params(
        error: ::StandardError,
        blk: T.proc.params(arg0: Value).returns(T::Boolean)
      ).returns(Mayak::Monads::Try[Value])
  end
  def filter_or(error, &blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#32
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
  end
  def flat_map(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#99
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def flat_map_failure(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#21
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
  end
  def map(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#90
  sig do
    abstract
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(::StandardError)
      ).returns(Mayak::Monads::Try[Value])
  end
  def map_failure(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#155
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        value: T.type_parameter(:NewValue)
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover(value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#176
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        error_type: T.class_of(StandardError),
        blk: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_on(error_type, &blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#164
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_with(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#184
  sig do
    type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_with_try(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#44
  sig { abstract.returns(T::Boolean) }
  def success?; end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#57
  sig do
    abstract
      .type_parameters(:NewValue)
      .params(
        value: T.type_parameter(:NewValue)
      ).returns(T.any(T.type_parameter(:NewValue), Value))
  end
  def success_or(value); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#82
  sig { abstract.params(blk: T.proc.params(arg0: Value).void).returns(Mayak::Monads::Try[Value]) }
  def tee(&blk); end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#112
  sig { abstract.returns(Mayak::Monads::Maybe[Value]) }
  def to_maybe; end

  # @abstract
  #
  # source://mayak//lib/mayak/monads/try.rb#108
  sig do
    abstract
      .type_parameters(:Failure)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:Failure))
      ).returns(Mayak::Monads::Result[T.type_parameter(:Failure), Value])
  end
  def to_result(&blk); end

  class << self
    # source://mayak//lib/mayak/monads/try.rb#210
    sig do
      type_parameters(:Value)
        .params(
          value: T.type_parameter(:Value),
          error: ::StandardError,
          blk: T.proc.returns(T::Boolean)
        ).returns(Mayak::Monads::Try[T.type_parameter(:Value)])
    end
    def check(value, error, &blk); end

    # source://mayak//lib/mayak/monads/try.rb#219
    sig { params(error: ::StandardError, blk: T.proc.returns(T::Boolean)).returns(Mayak::Monads::Try[::NilClass]) }
    def guard(error, &blk); end

    # source://mayak//lib/mayak/monads/try.rb#193
    sig do
      type_parameters(:Value)
        .params(
          results: T::Array[Mayak::Monads::Try[T.type_parameter(:Value)]]
        ).returns(Mayak::Monads::Try[T::Array[T.type_parameter(:Value)]])
    end
    def sequence(results); end
  end
end

# source://mayak//lib/mayak/monads/try.rb#391
class Mayak::Monads::Try::Failure
  extend T::Generic
  include ::Mayak::Monads::Try

  Value = type_member

  # source://mayak//lib/mayak/monads/try.rb#400
  sig(:final) { params(value: ::StandardError).void }
  def initialize(value); end

  # source://mayak//lib/mayak/monads/try.rb#479
  sig do
    override
      .type_parameters(:Result)
      .params(
        failure_branch: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:Result)),
        success_branch: T.proc.params(arg0: Value).returns(T.type_parameter(:Result))
      ).returns(T.type_parameter(:Result))
  end
  def either(failure_branch, success_branch); end

  # source://mayak//lib/mayak/monads/try.rb#440
  sig(:final) { returns(::StandardError) }
  def failure; end

  # source://mayak//lib/mayak/monads/try.rb#450
  sig(:final) { override.returns(T::Boolean) }
  def failure?; end

  # source://mayak//lib/mayak/monads/try.rb#465
  sig(:final) { override.params(value: ::StandardError).returns(::StandardError) }
  def failure_or(value); end

  # source://mayak//lib/mayak/monads/try.rb#435
  sig do
    override
      .params(
        error: ::StandardError,
        blk: T.proc.params(arg0: Value).returns(T::Boolean)
      ).returns(Mayak::Monads::Try[Value])
  end
  def filter_or(error, &blk); end

  # source://mayak//lib/mayak/monads/try.rb#423
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
  end
  def flat_map(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#507
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def flat_map_failure(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#410
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
  end
  def map(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#497
  sig do
    override
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(::StandardError)
      ).returns(Mayak::Monads::Try[Value])
  end
  def map_failure(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#549
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        value: T.type_parameter(:NewValue)
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover(value); end

  # source://mayak//lib/mayak/monads/try.rb#535
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        error_type: T.class_of(StandardError),
        blk: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_on(error_type, &blk); end

  # source://mayak//lib/mayak/monads/try.rb#559
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_with(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#445
  sig(:final) { override.returns(T::Boolean) }
  def success?; end

  # source://mayak//lib/mayak/monads/try.rb#460
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        value: T.any(T.type_parameter(:NewValue), Value)
      ).returns(T.any(T.type_parameter(:NewValue), Value))
  end
  def success_or(value); end

  # source://mayak//lib/mayak/monads/try.rb#488
  sig(:final) { override.params(blk: T.proc.params(arg0: Value).void).returns(Mayak::Monads::Try[Value]) }
  def tee(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#522
  sig(:final) { override.returns(Mayak::Monads::Maybe[Value]) }
  def to_maybe; end

  # source://mayak//lib/mayak/monads/try.rb#517
  sig do
    override
      .type_parameters(:Failure)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:Failure))
      ).returns(Mayak::Monads::Result[T.type_parameter(:Failure), Value])
  end
  def to_result(&blk); end
end

# source://mayak//lib/mayak/monads/try.rb#564
module Mayak::Monads::Try::Mixin
  include ::Kernel

  # source://mayak//lib/mayak/monads/try.rb#577
  sig do
    type_parameters(:Value)
      .params(
        exception_classes: T.class_of(StandardError),
        blk: T.proc.returns(T.type_parameter(:Value))
      ).returns(Mayak::Monads::Try[T.type_parameter(:Value)])
  end
  def Try(*exception_classes, &blk); end

  # source://mayak//lib/mayak/monads/try.rb#622
  sig do
    type_parameters(:Value)
      .params(
        value: T.type_parameter(:Value),
        error: ::StandardError,
        blk: T.proc.returns(T::Boolean)
      ).returns(T.type_parameter(:Value))
  end
  def check_try!(value, error, &blk); end

  # source://mayak//lib/mayak/monads/try.rb#603
  sig do
    type_parameters(:Value)
      .params(
        value: Mayak::Monads::Try[T.type_parameter(:Value)]
      ).returns(T.type_parameter(:Value))
  end
  def do_try!(value); end

  # source://mayak//lib/mayak/monads/try.rb#591
  sig do
    type_parameters(:Value)
      .params(
        blk: T.proc.returns(T.type_parameter(:Value))
      ).returns(Mayak::Monads::Try[T.type_parameter(:Value)])
  end
  def for_try(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#627
  sig { params(error: ::StandardError, blk: T.proc.returns(T::Boolean)).void }
  def guard_try!(error, &blk); end
end

# source://mayak//lib/mayak/monads/try.rb#631
class Mayak::Monads::Try::Mixin::Halt < ::StandardError
  extend T::Generic

  SuccessType = type_member

  # source://mayak//lib/mayak/monads/try.rb#642
  sig { params(result: Mayak::Monads::Try[SuccessType]).void }
  def initialize(result); end

  # source://mayak//lib/mayak/monads/try.rb#639
  sig { returns(Mayak::Monads::Try[SuccessType]) }
  def result; end
end

# source://mayak//lib/mayak/monads/try.rb#223
class Mayak::Monads::Try::Success
  extend T::Generic
  include ::Mayak::Monads::Try

  Value = type_member

  # source://mayak//lib/mayak/monads/try.rb#232
  sig(:final) { params(value: Value).void }
  def initialize(value); end

  # source://mayak//lib/mayak/monads/try.rb#309
  sig do
    override
      .type_parameters(:Result)
      .params(
        failure_branch: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:Result)),
        success_branch: T.proc.params(arg0: Value).returns(T.type_parameter(:Result))
      ).returns(T.type_parameter(:Result))
  end
  def either(failure_branch, success_branch); end

  # source://mayak//lib/mayak/monads/try.rb#280
  sig(:final) { override.returns(T::Boolean) }
  def failure?; end

  # source://mayak//lib/mayak/monads/try.rb#295
  sig(:final) { override.params(value: ::StandardError).returns(::StandardError) }
  def failure_or(value); end

  # source://mayak//lib/mayak/monads/try.rb#261
  sig do
    override
      .params(
        error: ::StandardError,
        blk: T.proc.params(arg0: Value).returns(T::Boolean)
      ).returns(Mayak::Monads::Try[Value])
  end
  def filter_or(error, &blk); end

  # source://mayak//lib/mayak/monads/try.rb#252
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
  end
  def flat_map(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#338
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def flat_map_failure(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#242
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: Value).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Try[T.type_parameter(:NewValue)])
  end
  def map(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#328
  sig do
    override
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(::StandardError)
      ).returns(Mayak::Monads::Try[Value])
  end
  def map_failure(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#376
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        value: T.type_parameter(:NewValue)
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover(value); end

  # source://mayak//lib/mayak/monads/try.rb#366
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        error_type: T.class_of(StandardError),
        blk: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_on(error_type, &blk); end

  # source://mayak//lib/mayak/monads/try.rb#386
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:NewValue))
      ).returns(Mayak::Monads::Try[T.any(T.type_parameter(:NewValue), Value)])
  end
  def recover_with(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#270
  sig(:final) { returns(Value) }
  def success; end

  # source://mayak//lib/mayak/monads/try.rb#275
  sig(:final) { override.returns(T::Boolean) }
  def success?; end

  # source://mayak//lib/mayak/monads/try.rb#290
  sig do
    override
      .type_parameters(:NewValue)
      .params(
        value: T.any(T.type_parameter(:NewValue), Value)
      ).returns(T.any(T.type_parameter(:NewValue), Value))
  end
  def success_or(value); end

  # source://mayak//lib/mayak/monads/try.rb#318
  sig(:final) { override.params(blk: T.proc.params(arg0: Value).void).returns(Mayak::Monads::Try[Value]) }
  def tee(&blk); end

  # source://mayak//lib/mayak/monads/try.rb#353
  sig(:final) { override.returns(Mayak::Monads::Maybe[Value]) }
  def to_maybe; end

  # source://mayak//lib/mayak/monads/try.rb#348
  sig do
    override
      .type_parameters(:Failure)
      .params(
        blk: T.proc.params(arg0: ::StandardError).returns(T.type_parameter(:Failure))
      ).returns(Mayak::Monads::Result[T.type_parameter(:Failure), Value])
  end
  def to_result(&blk); end
end

# source://mayak//lib/mayak/numeric.rb#7
module Mayak::Numeric
  class << self
    # source://mayak//lib/mayak/numeric.rb#29
    sig do
      params(
        value: T.nilable(T.any(::BigDecimal, ::Float, ::Integer, ::String))
      ).returns(Mayak::Monads::Maybe[::BigDecimal])
    end
    def parse_decimal(value); end

    # source://mayak//lib/mayak/numeric.rb#11
    sig do
      params(
        value: T.nilable(T.any(::BigDecimal, ::Float, ::Integer, ::String))
      ).returns(Mayak::Monads::Maybe[::Float])
    end
    def parse_float(value); end

    # source://mayak//lib/mayak/numeric.rb#20
    sig { params(value: T.nilable(T.any(::BigDecimal, ::Integer, ::String))).returns(Mayak::Monads::Maybe[::Integer]) }
    def parse_integer(value); end

    # source://mayak//lib/mayak/numeric.rb#47
    sig { params(value: ::BigDecimal, total: ::BigDecimal).returns(::BigDecimal) }
    def percent_of(value:, total:); end
  end
end

# source://mayak//lib/mayak/predicates/rule.rb#5
module Mayak::Predicates; end

# source://mayak//lib/mayak/predicates/rule.rb#6
class Mayak::Predicates::Rule
  extend T::Generic

  A = type_member

  # source://mayak//lib/mayak/predicates/rule.rb#17
  sig { params(blk: T.proc.params(arg0: A).returns(T::Boolean)).void }
  def initialize(&blk); end

  # @return [Mayak::Predicates::Rule[A]]
  #
  # source://sorbet-runtime/0.5.11349/lib/types/private/methods/_methods.rb#257
  def !(*args, **_arg1, &blk); end

  # @param another [Mayak::Predicates::Rule[A]]
  # @return [Mayak::Predicates::Rule[A]]
  #
  # source://sorbet-runtime/0.5.11349/lib/types/private/methods/_methods.rb#257
  def &(*args, **_arg1, &blk); end

  # source://mayak//lib/mayak/predicates/rule.rb#35
  sig { params(another: Mayak::Predicates::Rule[A]).returns(Mayak::Predicates::Rule[A]) }
  def any(another); end

  # source://mayak//lib/mayak/predicates/rule.rb#27
  sig { params(another: Mayak::Predicates::Rule[A]).returns(Mayak::Predicates::Rule[A]) }
  def both(another); end

  # source://mayak//lib/mayak/predicates/rule.rb#22
  sig { params(object: A).returns(T::Boolean) }
  def call(object); end

  # source://mayak//lib/mayak/predicates/rule.rb#14
  sig { returns(T.proc.params(arg0: A).returns(T::Boolean)) }
  def fn; end

  # source://mayak//lib/mayak/predicates/rule.rb#55
  sig do
    type_parameters(:B)
      .params(
        function: Mayak::Function[T.type_parameter(:B), A]
      ).returns(Mayak::Predicates::Rule[T.type_parameter(:B)])
  end
  def from(function); end

  # source://mayak//lib/mayak/predicates/rule.rb#43
  sig { returns(Mayak::Predicates::Rule[A]) }
  def negate; end

  # source://mayak//lib/mayak/predicates/rule.rb#62
  sig { returns(Mayak::Predicates::Rule[T.nilable(A)]) }
  def presence; end

  # @param another [Mayak::Predicates::Rule[A]]
  # @return [Mayak::Predicates::Rule[A]]
  #
  # source://sorbet-runtime/0.5.11349/lib/types/private/methods/_methods.rb#257
  def |(*args, **_arg1, &blk); end
end

# source://mayak//lib/mayak/random.rb#5
module Mayak::Random
  class << self
    # source://mayak//lib/mayak/random.rb#11
    sig { params(number: T.any(::Float, ::Integer), jitter: ::Float).returns(::Float) }
    def jittered(number, jitter: T.unsafe(nil)); end
  end
end

# source://mayak//lib/mayak/random.rb#8
Mayak::Random::DEFAULT_JITTER = T.let(T.unsafe(nil), Float)

# source://mayak//lib/mayak/version.rb#5
Mayak::VERSION = T.let(T.unsafe(nil), String)

# source://mayak//lib/mayak/weak_ref.rb#5
class Mayak::WeakRef
  extend T::Generic

  Value = type_member

  # source://mayak//lib/mayak/weak_ref.rb#17
  sig { params(value: Value).void }
  def initialize(value); end

  # source://mayak//lib/mayak/weak_ref.rb#31
  sig { returns(Mayak::Monads::Maybe[Value]) }
  def deref; end

  # source://mayak//lib/mayak/weak_ref.rb#22
  sig { returns(Value) }
  def deref!; end
end

# source://mayak//lib/mayak/weak_ref.rb#11
class Mayak::WeakRef::EmptyReferenceError < ::StandardError; end
